project_path: /web/_project.yaml
book_path: /web/updates/_book.yaml
description: Learn how to design and implement reauth UX in your website using WebAuthn standard and a fingerprint sensor.

{# wf_updated_on: 2018-11-05 #}
{# wf_published_on: 2018-11-09 #}
{# wf_tags: webauthn, credentials, sign-in #}
{# wf_featured_image: /web/updates/images/2018/11/webauthn-reauth-ux.png #}
{# wf_featured_snippet: Learn how to design and implement reauth UX in your website using WebAuthn standard and a fingerprint sensor. #}
{# wf_blink_components: Blink>WebAuthentication #}

# Implementing fingerprint reauth UX with Webauthn {: .page-title }

{% include "web/_shared/contributors/agektmr.html" %}

## Introduction

[WebAuthn (Web Authentication API)](https://www.w3.org/TR/webauthn/) is a new 
web standard that enables you to use strong authentication on the web. It's 
[shipped in Chrome](/web/updates/2018/05/webauthn), 
Firefox and Edge. Webkit is also [implementing actively 
it](https://webkit.org/status/#feature-web-authentication).

[FIDO Alliance](https://fidoalliance.org) started working on WebAuthn as part of 
FIDO2 standard. FIDO2 consists of:

* **CTAP2** that defines a communication protocol between clients and 
  authenticators (hardware device that generates key pairs).
* **WebAuthn** that defines JavaScript API to handle credentials on 
  authenticators through web browsers.

Authenticators are hardware devices that has various forms and transports. They 
can generate a key pair for a user and the origin of a website. One form of 
authenticators include security keys:

<img src="/web/updates/images/2018/11/webauthn-security-keys.jpg" />  
The security keys shown above are Google Titan Keys which support NFC and BLE, 
USB transport respectively.

With security keys, a website can ensure that the user trying to sign-in owns 
the same device physically and there's a human who can tap it. Along with a 
password (what you know), security keys can play one factor role (what you have) 
in two factor authentication scenarios.

<img src="/web/updates/images/2018/11/webauthn-fingerprint.png" width="344" height="295">

Other authenticator examples include fingerprint sensors that are built into 
computer devices. Unlike security keys, because consumers don't have to spend 
additional time and money to own them separately, owners of such devices can 
quickly become a potential customer of your WebAuthn enabled website.

We consider WebAuthn can give you three additional sign-in scenarios:

1. Reauth
1. Second factor
1. Passwordless auth

In this article, we'll guide you through how to design and implement a reauth 
scenario using WebAuthn with a fingerprint sensor on Android or macOS.

### What is reauth?

Before going into details, let's define what is "reauth" exactly.

Reauth is an additional authentication that is required after initial 
authentication by accessing certain parts of a website. They are typically areas 
where a transaction is performed, or sensitive information is provided.

* Send purchased item to a new address
* Transfer money from your bank account to another
* View privacy protected information
* Change a password

For example, accessing [Chrome Web Store's developer 
dashboard](https://chrome.google.com/webstore/developer/dashboard) almost always 
asks you to sign-in to your Google account again, unless you did so very 
recently. This is because modifying a Chrome Extension can affect security and 
privacy of hundreds and millions of users who installed it. Protecting the page 
by double checking the developer's identity is tremendously important. Also in 
the very near future, it's [going to mandate a second 
factor](https://blog.chromium.org/2018/10/trustworthy-chrome-extensions-by-default.html) 
for ensuring extra security.

While reauth ensures stronger security, it's a burden for end users to type a 
password and provide a second factor like OTP (One Time Password), every time 
they try to access a sensitive area. OTP is generated by an authenticator app or 
sent via SMS and email, but this whole process is cumbersome for users.

With WebAuthn and fingerprint sensor, we can drastically simplify this process 
as easy as a tap of a finger, along with a better security.

Note: Your fingerprint data won't leave the device. It's security stored in the 
area any software won't access directly. This also means users will have to 
register their fingerprint per device.

Let's start with seeing how a fingerprint reauth experience would look like.

## User experience
### Credential registration:

On each device, user has to register their credential to the device.

1. User landing on Tri-bank.
1. Initial sign-in should be done with an id...
1. And a password (and optionally a second factor).
1. After signing in, the site shows a promo to optionally enable sign-in with a 
   fingerprint.
1. Turning it on pops up a browser native dialog.
1. By user tapping on a fingerprint sensor on their device, the dialog closes 
   and now fingerprint reauth is enabled.

<img src="/web/updates/images/2018/11/webauthn-flow-1.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-2.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-3.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-4.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-5.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-6.png" width="226" height="404" />

### Reauth:

After registering a credential, whenever user needs an authentication can be 
performed with a fingerprint.

1. User coming back to the website.
1. Browser native dialog pops up to verify identity with a fingerprint instead 
   of showing a password form.
1. By user tapping on a fingerprint sensor, the dialog closes.
1. The user is successfully signed-in. (When fingerprint reauth is not 
   successful, you may fallback to sign-in with id and password)

<img src="/web/updates/images/2018/11/webauthn-flow-1.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-5.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-7.png" width="226" height="404" />
<img src="/web/updates/images/2018/11/webauthn-flow-6.png" width="226" height="404" />

Note: Alternative design idea would be to make users permanently signed in while 
requiring them to reauth whenever stricter security is required. E-commerce 
website may want to implement this design. Let users explore the shop signed in, 
only request reauth when they proceed to purchase the items in the cart across 
devices.

Now, let's dive into the implementation details of fingerprint reauth.

Warning: Following sections are targeted at developers who have already read other articles about WebAuthn and understand the basics of how it works.

## Registering a credential

Before performing reauth, user has to register a credential using a fingerprint 
enabled authenticator. Following is an overview of client side code.

On browser:  
```js
async registerReauthKey() {  
  // Feature detection  
  if (!window.PublicKeyCredential)  
    throw 'WebAuthn not supported on this browser.';

  // If reauth key is already registered, no need to register  
  const credId = localStorage.getItem('reauth_key');  
  if (credId !== null)  
    throw 'Reauth key already registered.';

  // Request credential creation options  
  const options = await this._fetch('/makeCred');

  // Decode the options  
  options.user.id = base64url.decode(options.user.id);  
  options.challenge = base64url.decode(options.challenge);

  // Create a public key credential  
  const cred = await navigator.credentials.create({  
    publicKey: options  
  });

  // Encode the credential  
  const parsedCred = await this._encodeAuthenticatorAttestationResponse(cred);

  // Verify the credential  
  const profile = await this._fetch('/regCred', parsedCred);

  // Store the credential id locally  
  localStorage.setItem('reauth_key', parsedCred.id);;

  return parsedCred.id;  
}
```

### Request a credential creation options

We start by creating an object that will be passed to WebAuthn's credential 
creation API as an option. A PublicKeyCredentialCreationOptions look something 
like this.

```js
const options = {  
  rp: ...,  
  user: ...,  
  challenge: ...   
  pubKeyCredParams: ...,  
  // excludeCredentials: [],  
  authenticatorSelection: {  
    authenticatorAttachment: 'platform',  
    // requireResidentKey: false,  
    userVerification: 'required'  
  },  
  attestation = "none"  
};
```

Let's have a look at key properties specific for reauth use case.

`challenge` is an arbitrary length of random bytes associated with a user session 
so that resulting credential can be properly mapped to the same user when 
registration is done. In order to achieve this goal, the challenge must be 
created at the server side. Encoding it with BASE64URL is a common practice when 
transferring WebAuthn related data over HTTP, since some of them tend to be 
binary when passed to WebAuthn.

`authenticatorSelection.authenticatorAttachment` should be '`platform`' as we
expect user to use platform authenticator. '`platform`' authenticator is a type
of authenticators which are built into the platform itself. This includes
fingerprint sensor attached to Android or macOS devices, facial recognition
mechanism through cameras on Windows devices, for example (Note that Windows
Hello is not supported in Google Chrome as of ver. 71, though it's supported in
Microsoft Edge.). If you choose '`cross-platform`' authenticator, user may use
authenticators that are detachable from the platform they are using.

`authenticatorSelection.userVerification` should be '`required`'. "User
Verification" requests an authenticator to verify the user identity using
methodologies such as fingerprint, facial recognition, PIN, etc. This makes an
authentication stronger by adding "who you are" in addition to "what you have"
which can prove "User Present".

![](/web/updates/images/2018/11/webauthn-three-factors.png)

Note: User verification with PIN is not implemented in Chrome as of ver. 71.

Note: Simple tap based security key should be sufficient to attest "User 
Present".

Note: You can check in advance whether a user has a platform UV (User Verifying) 
authenticator by calling 
PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable(). It returns 
a promise that resolves to true if available.

`excludeCredentials` is used to prevent creating multiple credentials for the same 
origin using the same authenticator by providing a list of already registered 
credentials. In reauth case, you don't have to worry about duplication so give 
it an empty array or don't include excludeCredentials at all.

`attestation` should be '`none`'. Attestation is data that describes the 
authenticator itself and this property provides a preference if you want to 
receive one or not. A server can use returned attestation to make sure that the 
user is using a valid authenticator.  
We discourage you to use one unless you are using WebAuthn for enterprise 
audience. Because:

* It requires user permission before generating a credential, which is an extra 
  step for the user.
* Attestation provides unique identifier per models. Risks user privacy.
* Whitelisting authenticator will damage WebAuthn ecosystem significantly.

<img src="/web/updates/images/2018/11/webauthn-attestation.png" width="354" height="164" />

We recommend constructing this object server side and pass it to a browser 
BASE64URL encoded.

Server side:  
```js
router.post('/makeCred', sessionCheck, async (req, res) =&gt; {  
  const profile = req.session.profile;

  const response = {};  
  response.rp = {  
    id: req.host,  
    name: 'Example'  
  };  
  response.user = {  
    displayName: profile.displayName,  
    // Randomly generate a user id and BASE64URL encode it  
    id: createBase64Random(),  
    name: profile.name  
  };  
  response.pubKeyCredParams = [{  
    type: 'public-key', alg: -7  
  }, {  
    type: 'public-key', alg: -257  
  }];  
  response.timeout = 1000 * 30;  
  // Randomly generate a challenge and BASE64URL encode it  
  response.challenge = createBase64Random();  
  req.session.challenge = response.challenge;

  const as = {}; // authenticatorSelection  
  as.authenticatorAttachment = 'platform';  
  as.userVerification = 'required';

  response.authenticatorSelection = as;  
  response.attestation = 'none';

  res.json(response);  
});
```

### Create a credential

Based on the object you just received from the server, call the Credential 
Management API to create a public key after decoding it.

```js
  // Request a credential creation options  
  const options = await this._fetch('/makeCred');

  options.user.id = base64url.decode(options.user.id);  
  options.challenge = base64url.decode(options.challenge);

  const cred = await navigator.credentials.create({  
    publicKey: options  
  });
```

This should prompt the user to verify the identity using fingerprint etc.

<img src="/web/updates/images/2018/11/webauthn-fingerprint.png" width="344" height="295">

Once a user verifies identity, you will receive a public-key credential.

### Register the credential

The public-key credential should be verified and stored for future use.  The 
resulted PublicKeyCredential should looks like this:

```js
{  
  id: ...,  
  rawId: ...,  
  type: 'public-key',  
  response: {  
    clientDataJSON: ...,  
    attestationObject: ...,  
    signature: ...,  
    userHandle: ...  
  }  
}
```

Encode necessary part of it with BASE64URL and pass it back to a server to 
verify.

```js
  const encodedCred = await this._encodeAuthenticatorAttestationResponse(cred);

  const profile = await this._fetch('/regCred', encodedCred);
```

On the server, verify the credential by:

* Checking if the challenge in clientDataJSON matches with the one you left in 
  the session.
* Checking if the origin in clientDataJSON matches with your serving origin.

Server side code would look like this:

```js
router.post('/regCred', sessionCheck, async (req, res) =&gt; {  
  const profile = req.session.profile;  
  const challenge = req.session.challenge;  
  const origin = `${req.protocol}://${req.get('host')}`;

  const credId = req.body.id;  
  const type = req.body.type;  
  const response = req.body.response;  
  if (!credId || !type || !response) {  
    res.status(400).send('`response` missing in request');  
    return;  
  }

  try {  
    const attestationObject = response.attestationObject;  
    const clientDataJSON = response.clientDataJSON;  
    if (!attestationObject || !clientDataJSON)  
      throw 'Invalid request.';

    // const signature = response.signature;  
    // const userHandle = response.userHandle;  
    const clientData = JSON.parse(base64url.decode(clientDataJSON));

    // Verify challenge  
    if (clientData.challenge !== challenge)  
      throw 'Wrong challenge code.';

    // Verify origin  
    if (clientData.origin !== origin)  
      throw 'Wrong origin.';

    // Skip checking attestation as we assume `fmt == 'none'`  
    // const buffer = base64url.toBuffer(attestationObject);  
    // const response = cbor.decodeAllSync(buffer)[0];

    const credentialData = {  
      credId: credId,  
      type: type,  
      transports: ['internal'],  
      // Ignore attestation  
      // response: response,  
      created: (new Date()).getTime(),  
      last_used: null  
    };  
      
    const store = new CredentialStore();  
    const _profile = await store.get(profile.id);  
    if (!_profile.reauthKeys) {  
      _profile.reauthKeys = [];  
    }  
    _profile.reauthKeys.push(credentialData);

    // Ignore authenticator for the moment  
    await store.save(profile.id, _profile);

    res.json(profile);  
  } catch (e) {  
    res.status(400).send(e);  
  }  
});
```

Once verification is done, register the credential by storing the credential id. 
Store the credential both to a server and a browser's local storage as it's 
strongly tied to the device with the platform authenticator. Don't worry about 
leaking the credential, it's a public key.

```js
  localStorage.setItem('reauth_key', credId);
```

Now the user's credential is registered and you are ready to perform reauth.

## Performing reauth

When a user tries to access a page that requires stronger authentication, 
perform reath.  
Before calling WebAuthn, make sure that

* The user needs to perform reauth because sufficient time has passed since 
  previous authentication.
* The user has a registered credential.
* The device is capable of User Verifying Platform Authenticator.

You can check in advance whether a user has a platform UV authenticator by 
calling PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable(). It 
returns a promise that resolves to true if available.

Warning: Always fallback to id/password entry form if reauth using fingerprint 
is not possible.

On browser:  
```js
async reauth() {  
  // Feature detection  
  if (!window.PublicKeyCredential)  
    throw 'WebAuthn not supported on this browser.';

  // If reauth key is not registered, abort  
  const credId = localStorage.getItem('reauth_key');  
  if (credId === null)  
    throw 'Reauth key not registered.';

  // Request credential request options  
  const url =`/reauth?key=${encodeURIComponent(credId)}`;  
  const options = await this._fetch(url);

  // Decode the options  
  options.challenge = base64url.decode(options.challenge);

  if (options.allowCredentials) {  
    for (let cred of options.allowCredentials) {  
      cred.id = base64url.decode(cred.id);  
    }  
  }

  // Get a public key credential  
  const cred = await navigator.credentials.get({  
    publicKey: options  
  });

  // Encode the credential  
  const parsedCred = await this._encodeAuthenticatorAssertionResponse(cred);

  // Verify the credential  
  return await this._fetch('/verifyReauth', parsedCred);  
}
```

### Request a credential request options

We start by creating an object that will be passed to WebAuthn's credential 
getting API as an option. A PublicKeyCredentialRequestOptions look something 
like this.

```js
const options = {  
  challenge: ...,  
  allowCredentials: [{  
    id: ..., // credential id  
    type: 'public-key',  
    transports: ['internal'] // platform authenticator  
  }],  
  userVerification: 'required'  
};
```

Let's have a look at key properties specific for reauth use case.

userVerfiication should be 'required' for the same reason mentioned earlier in 
this post. This restricts to be user verifiable authenticator.

allowCredentials whitelist authenticators that matches credential descriptors 
provided as an array. In reauth case, you are supposed to provide a single 
credential descriptor that matches the one stored locally.

Server side:  
```js
router.get('/reauth', sessionCheck, async (req, res) =&gt; {  
  const key = req.query.key;

  const response = {};  
  response.userVerification = 'required';  
  response.challenge = createBase64Random();

  req.session.challenge = response.challenge;

  response.allowCredentials = [{  
    id: key,  
    type: 'public-key',  
    transports: ['internal']  
  }];

  res.json(response);  
});
```

### Get a credential

Based on the object you just received from the server, call the Credential 
Management API to get a public key after decoding it.

```js
  // Decode the options  
  options.challenge = base64url.decode(options.challenge);

  if (options.allowCredentials) {  
    for (let cred of options.allowCredentials) {  
      cred.id = base64url.decode(cred.id);  
    }  
  }

  // Get a public key credential  
  const cred = await navigator.credentials.get({  
    publicKey: options  
  });
```

This should prompt a user to verify the identity using fingerprint etc.

<img src="/web/updates/images/2018/11/webauthn-fingerprint.png" width="344" height="295">

Once a user verifies identity, you will receive a public-key credential.

### Verify the credential and authenticate

The public-key credential should be verified before authenticating the user. 
This looks very similar to the object you received when registering an 
authenticator, except response.attestationObject is replaced with 
response.authenticatorData.

```js
{  
  id: ...,  
  rawId: ...,  
  type: 'public-key',  
  response: {  
    clientDataJSON: ...,  
    authenticatorData: ...,  
    signature: ...,  
    userHandle: ...  
  }  
}
```

Encode necessary part of it with BASE64URL and pass it back to a server to 
verify.

```js
  // Encode the credential  
  const parsedCred = await this._encodeAuthenticatorAssertionResponse(cred);

  // Verify the credential  
  return await this._fetch('/verifyReauth', parsedCred);
```

On the server, verify the credential by:

* Checking if the challenge in clientDataJSON matches with the one you left in 
  the session.
* Checking if the origin in clientDataJSON matches with your serving origin.
* Checking that the credential id matches the one stored to database.

Server side:  
```js
router.post('/verifyReauth', sessionCheck, async (req, res) =&gt; {  
  const profile = req.session.profile;  
  const challenge = req.session.challenge;  
  const origin = `${req.protocol}://${req.get('host')}`;

  const credId = req.body.id;  
  const type = req.body.type;  
  const response = req.body.response;  
  if (!credId || !type || !response) {  
    res.status(400).send('`response` missing in request');  
    return;  
  }

  try {  
    const authenticatorData = response.authenticatorData;  
    const clientDataJSON = response.clientDataJSON;  
    if (!authenticatorData || !clientDataJSON)  
      throw 'Invalid request.';

    // const signature = response.signature;  
    // const userHandle = response.userHandle;  
    const clientData = JSON.parse(base64url.decode(clientDataJSON));

    // Verify challenge  
    if (clientData.challenge !== challenge)  
      throw 'Wrong challenge code.';

    // Verify origin  
    if (clientData.origin !== origin)  
      throw 'Wrong origin.';

    // Skip checking attestation as we assume `fmt == 'none'`  
    // const buffer = base64url.toBuffer(authenticatorData);  
    // const response = cbor.decodeAllSync(buffer)[0];

    const store = new CredentialStore();  
    const _profile = await store.get(profile.id);  
    let authr = null;  
    if (_profile.reauthKeys) {  
      for (let _authr of _profile.reauthKeys) {  
        if (_authr.credId === credId) {  
          authr = _authr;  
          break;  
        }  
      }  
    }  
    if (!authr) {  
      res.status(400).send('Matching authenticator not found');  
      return;  
    }

    // Update timestamp  
    const now = (new Date()).getTime();  
    authr.last_used = now;  
    profile.last_auth = now;

    // Ignore authenticator for the moment  
    store.save(profile.id, _profile);

    res.json(profile);  
  } catch (e) {  
    res.status(400).send(e);  
  }  
});
```

Once verification is done, you can let the user sign-in.

## Summary

Important concepts you have learned in this article:

* Platform authenticators
* "User Present" and "User Verification"
* Reauth credential should stored both locally and remotely.

{% include "web/_shared/rss-widget-updates.html" %}

{% include "comment-widget.html" %}
